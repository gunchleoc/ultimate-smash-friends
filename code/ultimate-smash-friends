#!/usr/bin/env python
################################################################################
# copyright 2008 Gabriel Pettier <gabriel.pettier@gmail.com>                   #
#                                                                              #
# This file is part of UltimateSmashFriends                                    #
#                                                                              #
# UltimateSmashFriends is free software: you can redistribute it and/or modify #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# UltimateSmashFriends is distributed in the hope that it will be useful,      #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with UltimateSmashFriends.  If not, see <http://www.gnu.org/licenses/>.#
################################################################################

from pygame.locals import QUIT
import pygame
import os, sys
import getopt

# our modules
from usf_modules.config import config, sound_config

from usf_modules.game import Game, NetworkServerGame, NetworkClientGame
from usf_modules.menu import Menu
from usf_modules.gui import Gui
from usf_modules.controls import Controls
from usf_modules.debug_utils import LOG
from usf_modules import loaders
from usf_modules import music

def usage():
    print """
    usage: ultimate-smash-friends [-h] [-a][-l level-name] [-p player1,player2...] [-s num] [-C address]

    -h --help : this help

    -a --author : See  authors of this game

    -c --character_creator : create new characters

    -l --level levelname : select level by name

    -p --players player1,player2... : select up tu 4 players, by name.

    -s --server num, same as --server num: will launch a game server accepting "num" before launching the game.

    -C --client address, same as --client num: will attempt to connect to a game server at address "address".
  
    if a level and at least two players are selected the game is launch
    directly, without menu, with this level and thoose players.

    """

def author():

    if 'CREDITS' not in os.listdir(os.path.join(config['SHARE_DIRECTORY'])):
        LOG().log(config['SHARE_DIRECTORY']+'/CREDITS file not found')
        sys.exit(0)
    else:
        author_file = open(os.path.join(config['SHARE_DIRECTORY'],'CREDITS'))
        print (author_file.read())
        author_file.close()

def launch_character_creator():
    os.popen(os.path.join(config['BIN_DIRECTORY'],'viewer'))

class main (object):
    """
    The main class, load some parameters, set initial states and take care of
    the game main loop.

    """
    def __init__(self, params):
        """
        The constructor, create the render surface, set the menu initial state,
        parse command line params if any, launch the menu or the game depending
        on parameters.

        """
        p = ''

        # analyse of command line parameters.
        try:
            opts, args = getopt.getopt(
                params, "hl:au:ch:p:s:C:nG", [
                    'help',
                    'author',
                    'character_creator',
                    'level=',
                    'players=',
                    'server=',
                    'client=',
                    'gui'
                    ]
                )
        except getopt.GetoptError:
            usage()
            sys.exit(2)
        game_type = 'local'
        self.newGui = True
        for option, argument in opts:
            if option in ["-h","--help"]:
                usage()
                sys.exit(2)
            if option in ["-a","--author"]:
                author()
                sys.exit(2)
            if option in ["-c","--character_creator"]:
                launch_character_creator()
                sys.exit(2)
            if option in ["-l","--level"]:
                level = argument
            if option in ["-p","--players"]:
                p = argument
            if option in ["-nG","--gui"]:
                self.newGui =False
            if option in ["-s","--server"]:
                game_type = 'server'
            if option in ['-C','--client']:
                game_type = 'client'
                address = argument

        players = ['characters'+os.sep+np for np in p.split(',')]

        pygame.init()

        if game_type == "server":
            self.game = NetworkServeupdate(p)
            self.clock = pygame.time.Clock()
            self.state = ""
            self.controls = Controls()
            self.menu = None

        elif game_type == "client":
            self.init_screen()
            self.init_sound()

            self.game = NetworkClientGame(players, level)
            self.state = "game"
            self.controls = Controls()
            if(self.newGui == True):
                self.menu = Gui()
            else:
                self.menu = Menu()

        else:
            self.init_screen()
            self.init_sound()
            self.LOG = LOG()

            if len(players) > 1 and level is not None:
                self.game = Game( self.screen, level, players )
                self.menu = None
                self.state = "game"
                self.clock = pygame.time.Clock()
                self.controls = Controls()

            else:
                self.screen.blit(
                    self.game_font.render(
                        "menus...",
                        True,
                        pygame.color.Color(
                            "white"
                            )
                        ),
                    (30, 4*config['SIZE'][1]/5)
                    )

                pygame.display.update()
                if(self.newGui == True):
                    self.menu = Gui(self.screen)
                else:
                    self.menu = Menu(self.screen)
                self.state = "menu"
                self.controls = Controls()

                self.clock = pygame.time.Clock()
                self.game = None
                level = None
                p = ""

    def init_screen(self):
        self.screen = pygame.display.set_mode(config['SIZE'])
        pygame.display.set_caption('Ultimate Smash Friends')
        icon = loaders.image(
            config['MEDIA_DIRECTORY']+
            os.sep+
            'gui'+
            os.sep+
            'icon.png'
            )[0]
        pygame.display.set_icon(icon)
        if config['FULLSCREEN'] == 1:
            pygame.display.toggle_fullscreen()
        # following operation can be quite long, so a loading screen is good
        if(self.newGui == True):
            image = loaders.image(
                config['MEDIA_DIRECTORY']+
                os.sep+
                'gui'+
                os.sep+
                config['THEME']+
                os.sep+
                'loading.png'
                )[0]
        else:
            image = loaders.image(
                config['MEDIA_DIRECTORY']+
                os.sep+
                'misc'+
                os.sep+
                'loading.png'
                )[0]

        self.game_font = pygame.font.Font(None, 50)
        self.screen.blit(image,(0,0))

    def init_sound(self):
        # TODO: timeout and error handling if sound is not initiasable.
        if sound_config['MUSIC'] == True:
            self.music = music.Music()

    def go(self):
        """
        The main game loop, take care of the state of the game/menu.

        """
        while (True):
            # update the fps counter
            self.clock.tick()
            if sound_config['MUSIC'] == True:
                self.music.update(self.state)

            # poll controls and update informations on current state of the UI
            self.state = self.controls.poll(self.game, self.menu, self.state)
            if self.state is "menu":
                # return of the menu update function may contain a new game
                # instance to switch to.
                newgame, game_ = self.menu.update(
                    self.state,
                    self.game,
                    self.controls
                    )
                if newgame:
                    if game_ is not self.game:
                        #LOG().log('new game')
                        del(self.game)
                        self.game = game_
                    self.state = 'game'
            else:
                self.state = self.game.update()
                if self.state == 'game':
                    self.game.draw(
                        debug_params={
                            #'controls': self.controls,
                            #'action':None,
                            }
                        )

            pygame.display.update()
            # verify there is not a QUIT event waiting for us, in case of we
            # have to quit.
            self.ended = pygame.event.get(QUIT)
            if self.ended :
                self.LOG.log('fps = '+str(self.clock.get_fps()))
                pygame.quit()
                break

if __name__ == '__main__':
    """
    Entry point of the game, if not imported from another script launch the
    main class with parameters (appart from program self name) if any.

    """
    # remove argv[0] as it's the program name and we don't care of it.
   #LOG().log(sys.argv)
    main(sys.argv[1:]).go()

