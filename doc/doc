class AI (Entity):
def choose_strategy (self, game) : def compute_computing_time () :
def find_path (self, game) : def get_enemy_num_by_rank (self, rank) :
def get_enemy_rank_by_num (self, num) :
def get_entity_by_num (self, num, game) :
def __init__ (self, num, game, entity_skinname
def jump (self, game, type
def jump_update (self, game) :
def kick (self, game, type
def localize_fall_zone (self, player, map) :
def reversed_or_not (self, side) :
def test_on_ground (game, lenght
def update_current_target (self, game) : def update_enemy (self, game) :
def update (self, dt, t, surface, game, coords
def use_strategy (self, game, dt) : def walk (self, side
average_computing_time
average_computing_time 
begin_computing_time
current_target
enemy_distance
enemy_number
enemy_position
fight_engaged
ignored_pl
in_jump
make_fall_priority
need_change_target
reversed
skill
strategy
target_x_offset
target_x_relative_state
target_y_offset
target_y_relative_state
walking_vector 

class Frame (object):
def addAgressivPoint(self, (x,y),(v,j)):
def __init__(self, image, time, vector, hardshape, name):
agressivpoints
agressivpoints_reverse
hardshape
image
image_reversed
LOG
name
time
vector

class PreciseTimedAnimation(Sprite):
def __del__(self):
def __init__( self, timedFrames, attribs, server
def start(self):
def update(self, _time, reversed
agressivpoints
duration
frames
hardshape
image
playing
rect
repeat
server_mode
_start_time
vector

class Sequence (object):
def compare(self, seq, game_instance):
def __init__(self, player, keys, action, condition
def __str__():
action
condition
keys
player

class Controls (object):
def assignKey(self, action):
def draw_rect(surface, rect, color
def getKeyByAction(self, action):
def handle_game_key( self, state, key, game_instance ):
def handle_menu_key( self, state, key, game):
def __init__(self):
def poll(self, game_instance, menu, state):
def reload(self):
def save(self):
keys
player_sequences
reverse_keymap
sequences

class LOG (object):
def __init__(self, out
def log(self, message, level
min_level
out
severities

class WrongEntityException(Exception):
def __init__(self):

class Entity (object):
def collide_point(self, (x,y)):
def dist(self, entity):
def draw(self, coords, zoom, surface):
def foot_collision_rect(self):
def get_block_vector(self, level_vector_blocs):
def move(self,(x,y), _from
def serialize(self):
def unserialize(self, string):
def update_floor_vector(self, level_moving_parts):
def update_physics(self, dt, game):
def update_points(self, x
def update(self, dt, t, surface, game, coords
def worldCollide(self, game):
if reversed: x
carried_by
entity_skin
entity_skin.animation.__start__time
entity_skin.current_animation
entity_skinname
entity_type
invincible
lives
name
num
number
onGround
percents
place
present
rect
reversed
vector
visible
walking_vector

class Entity_skin (object):
def change_animation( self, anim_name, game, params
def __del__(self):
def __init__( self, dir_name
def update(self, t, reversed
action_events
animation
animation_change
animations
current_animation
filename
hardshape
image
name
sounds

class BadPlayersNetworkParamError(Exception):

class Game (object):
def addItem(self, item
def __del__(self):
def draw(self, debug_params
def __init__(self, screen, level
def update_events(self, dt):
def update(self, debug_params
ended
ending
events
font
game_font
heart
icon_space
items
last_clock
level
level_place
LOG
players
screen
tmp_surface
type
zoom

class NetworkServerGame(Game):
def begin(self, level, players_):
def draw(self):
def __init__(self, players_
def update_game_state_string(self):
def update(self):
accepting
ended
ending
events
game_string
items
last_clock
level
LOG
num_players
players
server
type

class NetworkClientGame(Game):
def begin( self, players
def fromPool(self, skin, movment, time):
def update(self, time):
connection
level
players
screen
skinpool
type

class Block (object):
def collide_rect(self, (x,y), (h,w)
def draw(self, surface, coords
def feedZoomedBloc(self, zoom ):
def __init__(self):
def __str__(self):
inThread
zoom_cache

class VectorBloc (Block):
def apply_vector(self, entity):
def __init__(self, rects, position, vector, relative, texture, server
collide_rects
position
rects
relative
texture
vector

class MovingPart (Block):
def get_movement(self):
def __init__(self, rects, texture, patterns, server
def update(self, level_time):
collide_rects
old_position
patterns
position
rects
texture, self.rect

class Level ( object ):
def collide_rect(self, (x,y), (h,w)
def __del__(self):
def draw_background(self, surface, coords
def draw_foreground(self, surface, coords
def draw_level(self, surface, coords
def feedZoomedLevel(self, zoom ):
def __init__(self, levelname
def load_image(name, colorkey
def load_keys(file
def update(self, time):
background
border
foreground
foreground_zoom_levels_cache
inThread
level, self.rect
level,self.rect
level_zoom_levels_cache
map
moving_blocs
name
vector_blocs

class Menu:
def draw_conf_keyboard(self, controls):
def draw_cursor(self, color, position):
def draw_level_selection(self):
def draw_menu(self, game):
def draw_player_rect( self, place, player ):
def draw_player_selection(self):
def __init__(self, surface):
def launch_game(self, game):
def update(self, state, game, controls):
characters
cursors
font
game_type
level
levels
menu_elements
players
R, self.V, self.B
R,self.V,self.B
selectors
small_font
state
surface

class Music (object):
def change_music(self, music, fading
def __init__(self):
def test_client():
def update(self, params
playing
playlist
time_begin

class NetworkError (RuntimeError):
def server_thread(client_socket, server, num, game_instance):

class Client(object):
def close(self):
def __init__(self, sock
def recieve(self):
def send(self, key, action
def update(self):
level
lock
messages
players
socket

class Server(object):
def close(self):
def del_entity(self, num):
def __del__(self):
def fetch(self):
def __init__(self, game_instance
def listen_function(self, game_instance):
def listen(self, clients
def new_entity(self, num, skin, position):
def new_player_from_string(self, data):
def send_updated_informations(self):
clients
game_instance
lock
messages
players
quit
serversocket
socket
votemap

class TimedEvent (object):
def condition(self):
def execute(self, dt):
def initiate(self):
def __init__( self, period, params
def update(self, deltatime):
done
params
period

class HealEvent(TimedEvent):
def condition(self):
def execute(self, dt):
params.percents

class DelItemEvent(TimedEvent):
def condition(self):
def __del__(self):
def execute(self, dt):

class BombExplode(TimedEvent):
def condition(self):
def execute(self, dt):
done

class DropRandomItem(TimedEvent):
def condition(self):
def execute(self, dt):
done

class ItemShower(TimedEvent):
def condition(self):
def execute(self,dt):
elapsed

class ThrowBomb(TimedEvent):
def condition(self):
def execute(self, deltatime):
done

class Gost(TimedEvent):
def condition(self):
def execute(self, deltatime):
params.vector
target_player

class ThrowMiniGost(TimedEvent):
def condition(self):
def execute(self, deltatime):
done

class InvinciblePlayer(TimedEvent):
def condition(self):
def __del__(self):
def execute(self, deltatime):
def initiate(self):
def myfilter(self, element):
done
params.invincible
params.visible

class DropPlayer(TimedEvent):
def condition(self):
def __del__(self):
def execute(self, deltatime):
def initiate(self):
params.percents
params.place
params.present
params.vector
params.visible
params.walking_vector

class PlayerOut(TimedEvent):
def condition(self):
def execute(self, deltatime):
def initiate(self):
params.present
xy

class PlayerStaticOnGround(TimedEvent):
def condition(self):
def execute(self, deltatime):
def __del__(self):
